

# This file was *autogenerated* from the file cycle.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
sage.repl.load.load(sage.repl.load.base64.b64decode("cGVybS5zYWdl"),globals(),False)

class Cycle :
    M = []
    c = []
    m = _sage_const_0 

    def __init__ (self, M, c, m) :
        self.M = M
        self.c = c
        self.m = m
    
    def is_cycle (self) :
        M = self.M
        c = self.c
        m = self.m

        if not is_perm (c) :
            return False
        
        if not is_cyclic (c) :
            return False
        
        if len (M) != m :
            return False
        
        if len (c) != m :
            return False
        
        return True

def cycle_d (C, A, x) :
    if not C.is_cycle () :
        return None

    if A == [] :
        return None
    
    if x not in A :
        return None
    
    M, c, m = C.M, C.c, C.m
    
    for e in A :
        if e not in M :
            return None
        
    idx = M.index (x)
    idk = c [idx] - _sage_const_1 
    k = M [idk]

    while k not in A :
        idx = idk
        idk = c [idx] - _sage_const_1 
        k = M [idk]

    return k 

def cycle_d_all (C, A) :
    c = []

    for x in A :
        k = cycle_d (C, A, x)
        if k == None :
            return None
        c.append (A.index (k) + _sage_const_1 )

    C2 = Cycle (A, c, len (A))
    return C2

def dist (C, x, y) :
    if not C.is_cycle () :
        return None
    
    if x == y :
        return None
    
    M, c = C.M, C.c

    if x not in M :
        return None
    if y not in M :
        return None

    idx = M.index (x)
    idk = c [idx] - _sage_const_1 
    k = M [idk]
    cpt = _sage_const_1 

    while (k != y) :
        idx = idk
        idk = c [idx] - _sage_const_1 
        k = M [idk]
        cpt = cpt + _sage_const_1 
    
    return cpt

def paires_croisees (C, x, y, u, v) :
    dxu = dist (C, x, u)
    dxy = dist (C, x, y)
    dxv = dist (C, x, v)

    if dxu == None :
        return False
    
    if dxy == None :
        return False
    
    if dxv == None :
        return False

    if dxu <= dxy and dxy <= dxv :
        return True
    
    if dxu >= dxy and dxy >= dxv :
        return True
    
    return False

def parts_non_croisees (C, A, B) :
    if not C.is_cycle () :
        return False
    
    M, c = C.M, C.c
    
    for e in A :
        if e in B :
            return False
        if e not in M :
            return False
    
    for e in B : 
        if e in A :
            return False
        if e not in M :
            return False
    
    for sA in Subsets (A, _sage_const_2 ) :
        sA = sorted (sA)
        x = sA [_sage_const_0 ]
        y = sA [_sage_const_1 ]
        for sB in Subsets (B, _sage_const_2 ) :
            sB = sorted (sB)
            u = sB [_sage_const_0 ]
            v = sB [_sage_const_1 ]
            if paires_croisees (C, x, y, u, v) :
                return False
    
    return True

def parts_nc_adj (C, A, B) :
    if not parts_non_croisees (C, A, B) :
        return False
    
    M, c = C.M, C.c

    for x in A :
        idx = M.index (x)
        idcx = c [idx] - _sage_const_1 
        cx = M [idcx]
        if cx in B :
            for y in B :
                idy = M.index (y)
                idcy = c [idy] - _sage_const_1 
                cy = M [idcy]
                if cy in A :
                    return True

    return False

def is_set_part (M, P) :
    R = []
    for p in P :
        R = R + p
    R = sorted (R)
    M2 = sorted (M)

    return (R == M)

def cycle_pnc (C, P) :
    if not C.is_cycle () :
        return False
    
    M, c = C.M, C.c

    if not is_set_part (M, P) :
        return False
    
    n = len (P)
    l = [i for i in range (n)]

    for s in Subsets (l, _sage_const_2 ) :
        p1 = P [s [_sage_const_0 ]]
        p2 = P [s [_sage_const_1 ]]
        if not parts_non_croisees (C, p1, p2) :
            return False
    
    return True

def get_crossing (C, P) :
    if not C.is_cycle () :
        return None, None
    
    M, c = C.M, C.c

    if not is_set_part (C, P) :
        return None, None
    
    n = len (P)
    l = [i for i in range (n)]

    for s in Subsets (l, _sage_const_2 ) :
        p1 = P [s [_sage_const_0 ]]
        p2 = P [s [_sage_const_1 ]]
        if not parts_non_croisees (C, p1, p2) :
            return p1, p2
    
    return None, None
    
def make_pnc (C, P) : 
    if not C.is_cycle () :
        return None
    
    M, c = C.M, C.c

    if not is_set_part (M, P) :
        return None
    
    while not cycle_pnc (C, P) :
        A, B = get_crossing (C, P)
        if A == None :
            return None
        if B == None :
            return None
        P.remove (A)
        P.remove (B)
        P.append (A + B)
    
    return P

